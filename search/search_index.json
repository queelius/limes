{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Algebraic Integrators","text":"<p>Modern C++20 header-only library for numerical integration, differentiation, and ODE solving.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Composable Architecture: Mix and match accumulators, quadrature rules, and integrators</li> <li>Generic Programming: Templates and concepts for type-safe numerical algorithms</li> <li>High Performance: SIMD support (AVX2) and OpenMP parallelization</li> <li>Comprehensive: Integration, differentiation, ODEs, and antiderivatives</li> <li>Well-Tested: 118+ unit tests with Google Test</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include \"algebraic_integrators.hpp\"\n\nint main() {\n    // Simple integration\n    auto f = [](double x) { return x * x; };\n    auto result = integrate_adaptive(f, 0.0, 1.0, 1e-8);\n\n    std::cout &lt;&lt; \"Integral: \" &lt;&lt; result.value &lt;&lt; std::endl;\n    // Output: Integral: 0.333333\n}\n</code></pre>"},{"location":"#components","title":"Components","text":"<ul> <li>Accumulators: Simple, Kahan, Neumaier, Klein, Pairwise</li> <li>Quadrature Rules: Gauss-Legendre, Gauss-Kronrod, Tanh-Sinh, Simpson</li> <li>ODE Solvers: Euler, Runge-Kutta 4</li> <li>Differentiation: Central finite difference, gradients</li> <li>Transforms: Coordinate transforms for infinite intervals and singularities</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Header-only library - just include the headers:</p> <pre><code>#include \"algebraic_integrators.hpp\"\n</code></pre> <p>Or with CMake:</p> <pre><code>find_package(algebraic_integrators REQUIRED)\ntarget_link_libraries(your_target ai::algebraic_integrators)\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>C++20 compliant compiler (GCC 10+, Clang 12+, MSVC 2019+)</li> <li>CMake 3.20+ (for building tests/examples)</li> <li>Google Test (for testing)</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":"<p>The library follows a composable architecture where components can be mixed and matched:</p> <ul> <li>Accumulators control numerical precision</li> <li>Quadrature Rules define integration methods</li> <li>Integrators combine rules with accumulators</li> <li>Transforms handle special cases (infinite intervals, singularities)</li> </ul>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#1-accumulators","title":"1. Accumulators","text":"<p>Control how floating-point summation is performed:</p> <ul> <li><code>simple_accumulator</code> - Standard summation</li> <li><code>kahan_accumulator</code> - Compensated summation</li> <li><code>neumaier_accumulator</code> - Improved Kahan</li> <li><code>klein_accumulator</code> - Second-order compensation</li> <li><code>pairwise_accumulator</code> - Divide-and-conquer summation</li> </ul>"},{"location":"architecture/#2-quadrature-rules","title":"2. Quadrature Rules","text":"<p>Integration methods:</p> <ul> <li><code>gauss_legendre_rule</code> - Gaussian quadrature</li> <li><code>gauss_kronrod_rule</code> - Adaptive Gauss-Kronrod</li> <li><code>tanh_sinh_rule</code> - Double exponential (best for singularities)</li> <li><code>simpson_rule</code> - Simpson's method</li> </ul>"},{"location":"architecture/#3-integrators","title":"3. Integrators","text":"<p>Combine accumulators with rules:</p> <pre><code>// Custom composition\nusing Acc = kahan_accumulator&lt;double&gt;;\nusing Rule = gauss_kronrod_rule&lt;Acc, 15, 31&gt;;\ngauss_kronrod_integrator&lt;Acc, 15, 31&gt; integrator;\n</code></pre>"},{"location":"architecture/#4-ode-solvers","title":"4. ODE Solvers","text":"<ul> <li><code>euler_ode1</code> - First-order Euler method</li> <li><code>rk4_ode1</code> - Runge-Kutta 4th order</li> <li>Second-order variants for systems</li> </ul>"},{"location":"architecture/#5-differentiation","title":"5. Differentiation","text":"<ul> <li><code>central_finite_difference</code> - 8th order accurate</li> <li><code>central_finite_difference_2nd</code> - Second derivatives</li> <li><code>grad</code> - Multivariable gradients</li> </ul>"},{"location":"architecture/#type-safety","title":"Type Safety","text":"<p>The library uses C++20 concepts for compile-time interface checking:</p> <pre><code>template &lt;typename T&gt;\nconcept accumulator = requires(T a, typename T::value_type v) {\n    { a.add(v) } -&gt; std::same_as&lt;void&gt;;\n    { a.result() } -&gt; std::same_as&lt;typename T::value_type&gt;;\n};\n</code></pre>"},{"location":"architecture/#performance","title":"Performance","text":"<ul> <li>Header-only - Zero runtime overhead</li> <li>Template specialization - Compiler optimizations</li> <li>SIMD support - Optional AVX2 acceleration</li> <li>Parallelization - Optional OpenMP support</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-integration","title":"Basic Integration","text":""},{"location":"examples/#simple-integral","title":"Simple Integral","text":"<pre><code>#include \"algebraic_integrators.hpp\"\n\nint main() {\n    // Integrate x\u00b2 from 0 to 1\n    auto f = [](double x) { return x * x; };\n    auto result = integrate_adaptive(f, 0.0, 1.0, 1e-10);\n\n    std::cout &lt;&lt; \"\u222bx\u00b2 dx from 0 to 1 = \" &lt;&lt; result.value &lt;&lt; std::endl;\n    // Output: 0.333333...\n}\n</code></pre>"},{"location":"examples/#trigonometric-function","title":"Trigonometric Function","text":"<pre><code>auto f = [](double x) { return std::sin(x); };\nauto result = integrate_adaptive(f, 0.0, M_PI, 1e-10);\n// result.value \u2248 2.0\n</code></pre>"},{"location":"examples/#custom-composition","title":"Custom Composition","text":""},{"location":"examples/#high-precision-integration","title":"High-Precision Integration","text":"<pre><code>using Acc = klein_accumulator&lt;double&gt;;\ngauss_kronrod_integrator&lt;Acc, 15, 31&gt; integrator;\n\nauto f = [](double x) { return std::exp(-x*x); };\nauto result = integrator(f, -5.0, 5.0, 1e-12);\n// Very accurate result\n</code></pre>"},{"location":"examples/#fast-integration","title":"Fast Integration","text":"<pre><code>using Acc = simple_accumulator&lt;float&gt;;\nsimpson_univariate_integrator&lt;Acc&gt; integrator;\n\nauto f = [](float x) { return x * x + 1.0f; };\nauto result = integrator(f, 0.0f, 10.0f, 1000);\n</code></pre>"},{"location":"examples/#ode-examples","title":"ODE Examples","text":""},{"location":"examples/#population-growth","title":"Population Growth","text":"<pre><code>using Acc = kahan_accumulator&lt;double&gt;;\nrk4_ode1&lt;Acc&gt; solver;\n\n// Logistic growth: dP/dt = r*P*(1 - P/K)\ndouble r = 0.1;  // Growth rate\ndouble K = 100.0; // Carrying capacity\n\nauto growth = [r, K](double t, double P) {\n    return r * P * (1.0 - P/K);\n};\n\n// Start with P(0) = 10\nauto result = solver(growth, 0.0, 10.0, 50.0, 0.1);\nstd::cout &lt;&lt; \"Population at t=50: \" &lt;&lt; result.value &lt;&lt; std::endl;\n</code></pre>"},{"location":"examples/#pendulum","title":"Pendulum","text":"<pre><code>rk4_ode2&lt;simple_accumulator&lt;double&gt;&gt; solver;\n\ndouble g = 9.81, L = 1.0;\nauto pendulum = [g, L](double t, double theta, double omega) {\n    return -(g/L) * std::sin(theta);\n};\n\n// Start at 30\u00b0 with zero velocity\nauto result = solver(pendulum, 0.0, M_PI/6, 0.0, 10.0, 0.01);\n</code></pre>"},{"location":"examples/#differentiation-examples","title":"Differentiation Examples","text":""},{"location":"examples/#derivative-of-polynomial","title":"Derivative of Polynomial","text":"<pre><code>auto f = [](double x) { return x*x*x - 2*x*x + x - 1; };\nauto f_prime = deriv(f);\n\ndouble x = 2.0;\nstd::cout &lt;&lt; \"f'(2) = \" &lt;&lt; f_prime(x) &lt;&lt; std::endl;\n// Output: 7.0 (exact: 3*4 - 4*2 + 1 = 7)\n</code></pre>"},{"location":"examples/#gradient-descent","title":"Gradient Descent","text":"<pre><code>// Minimize f(x,y) = (x-3)\u00b2 + (y-4)\u00b2\nauto f = [](const std::vector&lt;double&gt;&amp; v) {\n    return std::pow(v[0]-3, 2) + std::pow(v[1]-4, 2);\n};\n\nstd::vector&lt;double&gt; x = {0.0, 0.0};\ndouble learning_rate = 0.1;\n\nfor (int i = 0; i &lt; 100; i++) {\n    auto gradient = grad(f, x);\n    x[0] -= learning_rate * gradient[0];\n    x[1] -= learning_rate * gradient[1];\n}\n// x converges to {3.0, 4.0}\n</code></pre>"},{"location":"examples/#antiderivatives","title":"Antiderivatives","text":""},{"location":"examples/#symbolic-antiderivative","title":"Symbolic Antiderivative","text":"<pre><code>using Acc = neumaier_accumulator&lt;double&gt;;\nsimpson_univariate_integrator&lt;Acc&gt; integrator;\n\nauto f = [](double x) { return 2*x; };\nauto F = antideriv(f, integrator);\n\nstd::cout &lt;&lt; \"F(5) = \" &lt;&lt; F(5.0) &lt;&lt; std::endl;\n// Output: 25.0 (antiderivative is x\u00b2)\n</code></pre>"},{"location":"examples/#initial-value-problem","title":"Initial Value Problem","text":"<pre><code>auto f = [](double x) { return std::sin(x); };\nauto F = antideriv(f, integrator);\n\n// Solve y' = sin(x), y(0) = 3\nauto y = solve(F, 0.0, 3.0);\n\nstd::cout &lt;&lt; \"y(\u03c0) = \" &lt;&lt; y(M_PI) &lt;&lt; std::endl;\n// Output: 5.0 (exact: 3 + 2 = 5)\n</code></pre>"},{"location":"examples/#parallel-integration","title":"Parallel Integration","text":"<pre><code>#include \"parallel_integrators.hpp\"\n\n// Enable OpenMP in CMake with AI_ENABLE_OPENMP=ON\nauto f = [](double x) { return std::exp(-x*x) * std::sin(x); };\nauto result = integrate_parallel(f, 0.0, 10.0, 1e-8);\n// Automatically uses all CPU cores\n</code></pre>"},{"location":"examples/#transform-examples","title":"Transform Examples","text":""},{"location":"examples/#infinite-interval","title":"Infinite Interval","text":"<pre><code>// Integrate exp(-x) from 0 to \u221e\nauto f = [](double x) { return std::exp(-x); };\nauto result = integrate_adaptive(\n    f, 0.0, std::numeric_limits&lt;double&gt;::infinity(), 1e-8\n);\n// result.value \u2248 1.0\n</code></pre>"},{"location":"examples/#singularity-at-endpoint","title":"Singularity at Endpoint","text":"<pre><code>// Integrate 1/\u221ax from 0 to 1\ntanh_sinh_integrator&lt;kahan_accumulator&lt;double&gt;&gt; integrator;\nauto f = [](double x) { return 1.0 / std::sqrt(x); };\nauto result = integrator(f, 0.0, 1.0, 1e-8);\n// result.value \u2248 2.0\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>This is a header-only library. Simply include the main header:</p> <pre><code>#include \"algebraic_integrators.hpp\"\n</code></pre> <p>Or with CMake:</p> <pre><code>find_package(algebraic_integrators REQUIRED)\ntarget_link_libraries(your_target ai::algebraic_integrators)\n</code></pre>"},{"location":"getting-started/#first-integration","title":"First Integration","text":"<pre><code>#include \"algebraic_integrators.hpp\"\n\nint main() {\n    // Define a function to integrate\n    auto f = [](double x) { return x * x; };\n\n    // Integrate from 0 to 1 with tolerance 1e-8\n    auto result = integrate_adaptive(f, 0.0, 1.0, 1e-8);\n\n    std::cout &lt;&lt; \"Integral: \" &lt;&lt; result.value &lt;&lt; std::endl;\n    // Output: 0.333333\n}\n</code></pre>"},{"location":"getting-started/#building-the-library","title":"Building the Library","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\nctest  # Run tests\n</code></pre>"},{"location":"getting-started/#cmake-options","title":"CMake Options","text":"<ul> <li><code>AI_BUILD_TESTS=ON/OFF</code> - Build test suite (default: ON)</li> <li><code>AI_BUILD_EXAMPLES=ON/OFF</code> - Build examples (default: ON)</li> <li><code>AI_ENABLE_AVX2=ON/OFF</code> - Enable AVX2 SIMD (default: OFF)</li> <li><code>AI_ENABLE_OPENMP=ON/OFF</code> - Enable OpenMP parallelization (default: OFF)</li> </ul>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>C++20 compliant compiler (GCC 10+, Clang 12+, MSVC 2019+)</li> <li>CMake 3.20+ (for building tests/examples)</li> <li>Google Test (for testing)</li> </ul>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#running-tests","title":"Running Tests","text":""},{"location":"testing/#all-tests","title":"All Tests","text":"<pre><code>cd build\nctest --output-on-failure\n</code></pre>"},{"location":"testing/#individual-test-suites","title":"Individual Test Suites","text":"<pre><code>./tests/test_accumulators\n./tests/test_integrators\n./tests/test_quadrature\n./tests/test_ode_solvers\n./tests/test_differentiation\n./tests/test_antiderivative\n./tests/test_transforms\n./tests/test_parallel\n</code></pre>"},{"location":"testing/#with-verbose-output","title":"With Verbose Output","text":"<pre><code>ctest -V\n</code></pre>"},{"location":"testing/#test-coverage","title":"Test Coverage","text":""},{"location":"testing/#generate-coverage-report","title":"Generate Coverage Report","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake\nmake coverage\n</code></pre> <p>View the report: <code>build/coverage/html/index.html</code></p>"},{"location":"testing/#current-coverage","title":"Current Coverage","text":"<p>The library has 118+ unit tests covering:</p> <ul> <li>Accumulators (42 tests): All accumulator types with float/double precision</li> <li>Quadrature Rules (tests): Gauss-Legendre, Gauss-Kronrod, Simpson</li> <li>Integrators (tests): Adaptive integration, transforms, edge cases</li> <li>ODE Solvers (26 tests): Euler and RK4 for 1st and 2nd order ODEs</li> <li>Differentiation (34 tests): First/second derivatives, gradients</li> <li>Antiderivatives (16 tests): Fundamental theorem, initial value problems</li> <li>Transforms (tests): Infinite intervals, singularities</li> <li>Parallel (tests): OpenMP parallelization</li> </ul>"},{"location":"testing/#test-framework","title":"Test Framework","text":"<p>Tests use Google Test framework with parameterized tests for type testing:</p> <pre><code>template &lt;typename T&gt;\nclass IntegratorTest : public ::testing::Test {};\n\nusing FloatTypes = ::testing::Types&lt;double, float&gt;;\nTYPED_TEST_SUITE(IntegratorTest, FloatTypes);\n\nTYPED_TEST(IntegratorTest, BasicIntegration) {\n    using T = TypeParam;\n    // Test works for both float and double\n}\n</code></pre>"},{"location":"testing/#writing-tests","title":"Writing Tests","text":""},{"location":"testing/#basic-test","title":"Basic Test","text":"<pre><code>TEST(IntegrationTest, SimplePolynomial) {\n    auto f = [](double x) { return x * x; };\n    auto result = integrate_adaptive(f, 0.0, 1.0, 1e-10);\n\n    EXPECT_NEAR(result.value, 1.0/3.0, 1e-8);\n}\n</code></pre>"},{"location":"testing/#parameterized-test","title":"Parameterized Test","text":"<pre><code>TYPED_TEST(AccumulatorTest, LinearSum) {\n    using T = TypeParam;\n    using Acc = kahan_accumulator&lt;T&gt;;\n\n    Acc acc;\n    for (int i = 0; i &lt; 100; i++) {\n        acc.add(T(0.1));\n    }\n\n    T tolerance = std::is_same_v&lt;T, float&gt; ? T(1e-4) : T(1e-10);\n    EXPECT_NEAR(acc.result(), T(10), tolerance);\n}\n</code></pre>"},{"location":"testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically on: - Push to main branch - Pull requests - Tagged releases</p>"},{"location":"testing/#benchmarks","title":"Benchmarks","text":"<p>Performance benchmarks are in <code>benchmarks/</code>:</p> <pre><code>./benchmarks/bench_integration\n./benchmarks/bench_accumulators\n./benchmarks/bench_ode\n</code></pre> <p>Results show: - Function evaluation counts - Wall-clock time - Accuracy vs. performance tradeoffs</p>"},{"location":"api/accumulators/","title":"Accumulators API","text":"<p>Accumulators control how floating-point summation is performed, trading speed for accuracy.</p>"},{"location":"api/accumulators/#available-accumulators","title":"Available Accumulators","text":""},{"location":"api/accumulators/#simple_accumulatort","title":"<code>simple_accumulator&lt;T&gt;</code>","text":"<p>Standard floating-point summation.</p> <pre><code>simple_accumulator&lt;double&gt; acc;\nacc.add(1.0);\nacc.add(2.0);\ndouble sum = acc.result(); // 3.0\n</code></pre> <p>Pros: Fastest Cons: Accumulates roundoff error Use when: Speed is critical, high precision not required</p>"},{"location":"api/accumulators/#kahan_accumulatort","title":"<code>kahan_accumulator&lt;T&gt;</code>","text":"<p>Compensated summation (Kahan algorithm).</p> <pre><code>kahan_accumulator&lt;double&gt; acc;\nfor (int i = 0; i &lt; 1000000; i++) {\n    acc.add(0.1);\n}\n// More accurate than simple accumulator\n</code></pre> <p>Pros: Much better precision than simple Cons: Slightly slower Use when: Summing many small values</p>"},{"location":"api/accumulators/#neumaier_accumulatort","title":"<code>neumaier_accumulator&lt;T&gt;</code>","text":"<p>Improved Kahan algorithm.</p> <pre><code>neumaier_accumulator&lt;double&gt; acc;\n</code></pre> <p>Pros: More robust than Kahan for mixed-magnitude values Cons: Slightly more expensive Use when: Values vary widely in magnitude</p>"},{"location":"api/accumulators/#klein_accumulatort","title":"<code>klein_accumulator&lt;T&gt;</code>","text":"<p>Second-order compensated summation.</p> <pre><code>klein_accumulator&lt;double&gt; acc;\n</code></pre> <p>Pros: Best accuracy of compensated algorithms Cons: More expensive than Kahan/Neumaier Use when: Maximum precision needed, performance acceptable</p>"},{"location":"api/accumulators/#pairwise_accumulatort","title":"<code>pairwise_accumulator&lt;T&gt;</code>","text":"<p>Divide-and-conquer summation.</p> <pre><code>pairwise_accumulator&lt;double&gt; acc;\n</code></pre> <p>Pros: Better balance of speed and accuracy Cons: Uses more memory for internal tree Use when: Good general-purpose choice</p>"},{"location":"api/accumulators/#accumulator-interface","title":"Accumulator Interface","text":"<p>All accumulators satisfy the <code>accumulator</code> concept:</p> <pre><code>template &lt;typename T&gt;\nconcept accumulator = requires(T a, typename T::value_type v) {\n    typename T::value_type;\n    { a.add(v) } -&gt; std::same_as&lt;void&gt;;\n    { a.result() } -&gt; std::same_as&lt;typename T::value_type&gt;;\n};\n</code></pre>"},{"location":"api/accumulators/#choosing-an-accumulator","title":"Choosing an Accumulator","text":"<pre><code>// Quick guide:\nsimple_accumulator      // Speed-critical, low precision OK\nkahan_accumulator       // Good default choice\nneumaier_accumulator    // Mixed magnitudes\nklein_accumulator       // Maximum precision\npairwise_accumulator    // Balance of speed/accuracy\n</code></pre>"},{"location":"api/accumulators/#usage-in-integrators","title":"Usage in Integrators","text":"<pre><code>// Compose with any integrator\nusing Acc = kahan_accumulator&lt;double&gt;;\ngauss_kronrod_integrator&lt;Acc, 15, 31&gt; integrator;\n\n// Or use with ODE solvers\nrk4_ode1&lt;klein_accumulator&lt;double&gt;&gt; solver;\n\n// Simpson's rule with neumaier\nsimpson_univariate_integrator&lt;neumaier_accumulator&lt;float&gt;&gt; integrator;\n</code></pre>"},{"location":"api/accumulators/#performance-comparison","title":"Performance Comparison","text":"Accumulator Speed Accuracy Memory Simple \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Kahan \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Neumaier \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Klein \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Pairwise \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50"},{"location":"api/differentiation/","title":"Differentiation API","text":""},{"location":"api/differentiation/#first-derivatives","title":"First Derivatives","text":""},{"location":"api/differentiation/#central_finite_difference","title":"<code>central_finite_difference</code>","text":"<p>8th-order accurate central difference method.</p> <pre><code>template &lt;typename F, typename T&gt;\nauto central_finite_difference(F f, T x, T h);\n</code></pre> <p>Parameters: - <code>f</code> - Function to differentiate - <code>x</code> - Point to evaluate derivative - <code>h</code> - Step size (typically 1e-3 to 1e-5)</p> <p>Returns: <code>differentiation_result&lt;T&gt;</code> with <code>.difference</code> and <code>.evaluations</code></p> <p>Example: <pre><code>auto f = [](double x) { return x * x; };\nauto result = central_finite_difference(f, 2.0, 0.001);\n// result.difference \u2248 4.0 (exact derivative at x=2)\n</code></pre></p>"},{"location":"api/differentiation/#second-derivatives","title":"Second Derivatives","text":""},{"location":"api/differentiation/#central_finite_difference_2nd","title":"<code>central_finite_difference_2nd</code>","text":"<p>Second-order derivative using central differences.</p> <pre><code>auto f = [](double x) { return std::sin(x); };\nauto result = central_finite_difference_2nd(f, M_PI/4, 0.001);\n// result.difference \u2248 -sin(\u03c0/4)\n</code></pre>"},{"location":"api/differentiation/#gradients","title":"Gradients","text":""},{"location":"api/differentiation/#grad","title":"<code>grad</code>","text":"<p>Compute gradient of multivariable function.</p> <pre><code>template &lt;typename F&gt;\nauto grad(F f, const std::vector&lt;double&gt;&amp; x, double h = 1e-5);\n</code></pre> <p>Example: <pre><code>// f(x,y) = x\u00b2 + y\u00b2\nauto f = [](const std::vector&lt;double&gt;&amp; v) {\n    return v[0]*v[0] + v[1]*v[1];\n};\n\nstd::vector&lt;double&gt; point = {1.0, 2.0};\nauto gradient = grad(f, point);\n// gradient = {2.0, 4.0}\n</code></pre></p>"},{"location":"api/differentiation/#functional-interface","title":"Functional Interface","text":""},{"location":"api/differentiation/#deriv","title":"<code>deriv</code>","text":"<p>Create a derivative function:</p> <pre><code>auto f = [](double x) { return x * x * x; };\nauto f_prime = deriv(f);\n\ndouble derivative_at_2 = f_prime(2.0); // \u2248 12.0\n</code></pre>"},{"location":"api/differentiation/#choosing-step-size","title":"Choosing Step Size","text":"<p>General guidance: - Too large: Truncation error dominates - Too small: Roundoff error dominates - Sweet spot: h \u2248 1e-3 to 1e-5 for double precision</p> <p>Adaptive step size: <pre><code>// Use smaller h for faster-changing functions\nauto h = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 1.0/3.0);\n</code></pre></p>"},{"location":"api/differentiation/#result-type","title":"Result Type","text":"<pre><code>template &lt;typename T&gt;\nstruct differentiation_result {\n    T difference;      // Computed derivative\n    size_t evaluations; // Function evaluations\n};\n</code></pre>"},{"location":"api/integration/","title":"Integration API","text":""},{"location":"api/integration/#high-level-functions","title":"High-Level Functions","text":""},{"location":"api/integration/#integrate_adaptive","title":"<code>integrate_adaptive</code>","text":"<p>Adaptive integration with automatic error control.</p> <pre><code>template &lt;typename F, typename T&gt;\nauto integrate_adaptive(F f, T a, T b, T tolerance);\n</code></pre> <p>Parameters: - <code>f</code> - Function to integrate - <code>a</code>, <code>b</code> - Integration bounds - <code>tolerance</code> - Desired accuracy</p> <p>Returns: <code>integration_result&lt;T&gt;</code> with <code>.value</code> and <code>.error</code></p> <p>Example: <pre><code>auto f = [](double x) { return std::sin(x); };\nauto result = integrate_adaptive(f, 0.0, M_PI, 1e-10);\n// result.value \u2248 2.0\n</code></pre></p>"},{"location":"api/integration/#integrator-classes","title":"Integrator Classes","text":""},{"location":"api/integration/#gauss_kronrod_integrator","title":"<code>gauss_kronrod_integrator</code>","text":"<p>High-accuracy adaptive integration.</p> <pre><code>template &lt;typename Acc, int N, int M&gt;\nclass gauss_kronrod_integrator;\n</code></pre> <p>Example: <pre><code>using Acc = kahan_accumulator&lt;double&gt;;\ngauss_kronrod_integrator&lt;Acc, 15, 31&gt; integrator;\nauto result = integrator([](double x) { return x*x; }, 0.0, 1.0, 1e-8);\n</code></pre></p>"},{"location":"api/integration/#tanh_sinh_integrator","title":"<code>tanh_sinh_integrator</code>","text":"<p>Best for functions with endpoint singularities.</p> <pre><code>using Acc = neumaier_accumulator&lt;double&gt;;\ntanh_sinh_integrator&lt;Acc&gt; integrator;\nauto result = integrator([](double x) { return 1/sqrt(x); }, 0.0, 1.0, 1e-8);\n</code></pre>"},{"location":"api/integration/#simpson_univariate_integrator","title":"<code>simpson_univariate_integrator</code>","text":"<p>Simple Simpson's rule integration.</p> <pre><code>simpson_univariate_integrator&lt;Acc&gt; integrator;\nauto result = integrator(f, a, b, n_intervals);\n</code></pre>"},{"location":"api/integration/#transforms","title":"Transforms","text":""},{"location":"api/integration/#infinite-intervals","title":"Infinite Intervals","text":"<pre><code>// Integrate from 0 to \u221e\nauto result = integrate_transform(\n    [](double x) { return std::exp(-x); },\n    0.0, std::numeric_limits&lt;double&gt;::infinity(),\n    1e-8\n);\n</code></pre>"},{"location":"api/integration/#singularities","title":"Singularities","text":"<pre><code>// Handle singularity at x=0\nauto result = integrate_tanh_sinh(\n    [](double x) { return 1/std::sqrt(x); },\n    0.0, 1.0, 1e-8\n);\n</code></pre>"},{"location":"api/integration/#result-type","title":"Result Type","text":"<pre><code>template &lt;typename T&gt;\nstruct integration_result {\n    T value;           // Computed integral\n    T error;           // Error estimate\n    size_t evaluations; // Function evaluations\n};\n</code></pre>"},{"location":"api/ode-solvers/","title":"ODE Solvers API","text":""},{"location":"api/ode-solvers/#first-order-odes","title":"First-Order ODEs","text":"<p>Solve equations of the form: dy/dt = f(t, y)</p>"},{"location":"api/ode-solvers/#euler_ode1","title":"<code>euler_ode1</code>","text":"<p>First-order Euler method (simple, less accurate).</p> <pre><code>template &lt;typename Acc&gt;\nclass euler_ode1;\n</code></pre> <p>Example: <pre><code>using Acc = simple_accumulator&lt;double&gt;;\neuler_ode1&lt;Acc&gt; solver;\n\n// Solve dy/dt = -y with y(0) = 1\nauto f = [](double t, double y) { return -y; };\nauto result = solver(f, 0.0, 1.0, 1.0, 0.01);\n// result.value \u2248 exp(-1) \u2248 0.368\n</code></pre></p>"},{"location":"api/ode-solvers/#rk4_ode1","title":"<code>rk4_ode1</code>","text":"<p>Fourth-order Runge-Kutta (more accurate).</p> <pre><code>rk4_ode1&lt;Acc&gt; solver;\nauto result = solver(f, t0, y0, t_final, step_size);\n</code></pre> <p>Parameters: - <code>f</code> - Function f(t, y) defining the ODE - <code>t0</code> - Initial time - <code>y0</code> - Initial value y(t0) - <code>t_final</code> - Final time - <code>step_size</code> - Integration step</p>"},{"location":"api/ode-solvers/#second-order-odes","title":"Second-Order ODEs","text":"<p>Solve equations of the form: d\u00b2y/dt\u00b2 = f(t, y, dy/dt)</p>"},{"location":"api/ode-solvers/#euler_ode2","title":"<code>euler_ode2</code>","text":"<pre><code>euler_ode2&lt;Acc&gt; solver;\n\n// Solve simple harmonic oscillator: d\u00b2y/dt\u00b2 = -y\nauto f = [](double t, double y, double dy) { return -y; };\nauto result = solver(f, 0.0, 1.0, 0.0, 1.0, 0.01);\n</code></pre>"},{"location":"api/ode-solvers/#rk4_ode2","title":"<code>rk4_ode2</code>","text":"<pre><code>rk4_ode2&lt;Acc&gt; solver;\nauto result = solver(f, t0, y0, dy0, t_final, step_size);\n</code></pre> <p>Parameters for second-order: - <code>f</code> - Function f(t, y, dy/dt) - <code>t0</code> - Initial time - <code>y0</code> - Initial position y(t0) - <code>dy0</code> - Initial velocity dy/dt(t0) - <code>t_final</code> - Final time - <code>step_size</code> - Integration step</p>"},{"location":"api/ode-solvers/#examples","title":"Examples","text":""},{"location":"api/ode-solvers/#exponential-decay","title":"Exponential Decay","text":"<pre><code>// dy/dt = -k*y\nauto decay = [k](double t, double y) { return -k * y; };\nrk4_ode1&lt;simple_accumulator&lt;double&gt;&gt; solver;\nauto result = solver(decay, 0.0, 100.0, 10.0, 0.1);\n</code></pre>"},{"location":"api/ode-solvers/#simple-harmonic-oscillator","title":"Simple Harmonic Oscillator","text":"<pre><code>// d\u00b2y/dt\u00b2 = -\u03c9\u00b2y\nauto sho = [omega](double t, double y, double dy) {\n    return -omega * omega * y;\n};\nrk4_ode2&lt;kahan_accumulator&lt;double&gt;&gt; solver;\nauto result = solver(sho, 0.0, 1.0, 0.0, 10.0, 0.01);\n</code></pre>"},{"location":"api/ode-solvers/#logistic-growth","title":"Logistic Growth","text":"<pre><code>// dy/dt = r*y*(1 - y/K)\nauto logistic = [r, K](double t, double y) {\n    return r * y * (1.0 - y/K);\n};\n</code></pre>"},{"location":"api/ode-solvers/#choosing-step-size","title":"Choosing Step Size","text":"<ul> <li>Smaller step: More accurate, slower</li> <li>Larger step: Faster, may be unstable</li> <li>Rule of thumb: Start with h = 0.01, adjust based on accuracy needs</li> <li>Use RK4 for better accuracy with larger steps</li> </ul>"},{"location":"api/ode-solvers/#result-type","title":"Result Type","text":"<pre><code>template &lt;typename T&gt;\nstruct ode_result {\n    T value;           // Solution at final time\n    size_t steps;      // Number of steps taken\n};\n</code></pre>"}]}